\chapter{数学之魅}

% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{求二进制数中1的个数} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:number-of-1s-in-binary}


\subsubsection{问题}
对于一个字节（8bit）的无符号整型变量，求其二进制表示中“1”的个数，要求算法的执行效率尽可能高。

\subsubsection{解法一}
利用模运算求取x的每个二进制位上是否为1。
\begin{Code}
// 时间复杂度O(lg(x))，空间复杂度O(1)
int count_1(int x) {
    int ans = 0;
    while (x != 0) {
        ans += (x % 2);
        x /= 2;
    }
    return ans;
}
\end{Code}

\subsubsection{解法二}
利用位运算求取x的每个二进制位上是否为1。位运算比模运算效率要高。
\begin{Code}
// 时间复杂度O(lg(x))，空间复杂度O(1)。
int count_2(int x) {
    int ans = 0;
    while (x != 0) {
        ans += (x & 0x01);
        x >>= 1;
    }
    return ans;
}
\end{Code}

\subsubsection{解法三}
利用按位与x\&(x-1)每次消除一个1，直到x为0。
\begin{center}
	\includegraphics{fig2-1-1.png}\\
	\figcaption{x \& (x-1)}\label{fig:number-of-ones-1}
\end{center}

\begin{Code}
// 时间复杂度O(M)，空间复杂度O(1)，其中M为二进制中1的个数。
int count_3(int x) {
    int ans = 0;
    while (x != 0) {
        x &= (x - 1);
        ans++;
    }
    return ans;
}
\end{Code}

\subsubsection{扩展问题1}
如果变量是32位的DWORD，你会使用上述的哪一种算法，或者改进哪一个算法？

\subsubsection{解法}
DWORD是一个32位无符号整数，因此该问题与原问题唯一的区别就是数据的范围不同。上述的三种解法都适用，而且都不要做任何改进。另外对于原书中的解法四使用分支操作和解法五查表法是不适用的。
时间复杂度和空间复杂度和原解法相同。

\subsubsection{扩展问题2}
给定两个正整数（二进制形式表示）A和B，问把A变为B需要改变多少位（bit）？也就是说，整数A和B的二进制表示中有多少位是不同的？

\subsubsection{解法}
拿到这个问题，我们首先想到的就是按照从低到高依次检查A和B的每一位是否相同，然后记录个数，时间复杂度是$O(log_2(Max(A,B)))$。
接着，我们会想能不能把复杂度降到只和位不同的个数相关。自然的就会想到通过一种位运算把不同的1取出来，这种位运算就是按位异或\^{}。计算C=A\^{}B，再计算C中1的个数就行了，可以采用原题中的解法三。


\begin{Code}
// 时间复杂度O(M)，空间复杂度O(1)，其中M为A和B二进制中不同的个数。
int exercise_2(int A, int B) {
    return count(A ^ B);	// 调用上面的count函数，计算A^B中1的个数。
}
\end{Code}

\subsubsection{扩展问题3}
给定整数$N$，判断它是否为2的幂，比如$0,2,4,8,\cdots$都是2的幂。这是原书中2.2的扩展问题，我感觉放在这里比较合适。

\subsubsection{解法}
\begin{Code}
boolean isPowerOf2(int N) {
    if (N >= 0 && ((N & (N - 1)) == 0)) return true;
    return false;
}
\end{Code}

% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{不要被阶乘吓倒} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:factorial-zeros}

\subsubsection{问题}
1. 给定一个整数$N$，那么$N$的阶乘$N!$末尾有多少个0呢？例如，$N=10$，$N!=3628800$，$N!$的末尾有两个0。

2. 求$N!$的二进制表示中最低位1的位置。

\subsubsection{问题1解法}
对$N!$进行质因数分解得到$N!=\prod {p_i}^{k_i}$，由于10=2×5，所以$N!$末尾0的个数只和5的指数有关。
计算$N!$中有多少个5，可以利用公式$\lfloor\frac{N}{5}\rfloor+\lfloor\frac{N}{5^2}\rfloor+\lfloor\frac{N}{5^3}\rfloor+\cdots$.
\begin{Code}
// 时间复杂度O(log5(N))，空间复杂度O(1)
int count_1(int N) {
    int ans = 0;
	while (N != 0) {
        N /= 5;
        ans += N;
    }
    return ans;
}
\end{Code}

\subsubsection{问题2解法一}
和问题1基本相同，只是现在二进制表示中末尾0的个数是和$N!$中2的指数有关。利用公式$\lfloor\frac{N}{2}\rfloor+\lfloor\frac{N}{2^2}\rfloor+\lfloor\frac{N}{2^3}\rfloor+\cdots$.
\begin{Code}
// 时间复杂度O(lg(N))，空间复杂度O(1)
int count_base_2(int N) {
    int ans = 0;
    while (N != 0) {
        N >>= 1;
        ans += N;
    }
    return ans;
}
\end{Code}

\subsubsection{问题2解法二}
$N!$中质因数2的个数等于$N-N$的二进制表示中1的个数。时间复杂度O(M)，M是$N$二进制表示中1的个数。这个解法技巧性太强了，不看解答完全想不到，而且扩展性差。

代码略。

\subsubsection{扩展问题}
求整数N的B进制表示中末尾0的个数。题目来源UVA 10061.

\subsubsection{解法}
对$N!$进行质因数分解得到$N!=\prod {p_i}^{k_i}$，对B进行质因数分解得到$N!=\prod {p_i}^{t_i}$，我们用$f(N,B)$来表示N的B进制表示中末尾0的个数，可以得出下面的等式:
$f(N,B) = min\{\frac{k_i}{t_i}\}$.
\begin{Code}
// 时间复杂度O(lgB(N))，空间复杂度O(1)
int countZeros(int n, int b) {
    int ans = Integer.MAX_VALUE;
    for (int i = 2; i <= b; i++) {
        if (b % i != 0) continue;
        int cnt = 0;
        while (b % i == 0) {
            b /= i;
            cnt++;
        }
        int tmp = 0, tn = n;
        while (tn != 0) {
            tn /= i;
            tmp += tn;
        }
        ans = Math.min(ans, tmp / cnt);
    }
    return ans;
}
\end{Code}
这里我们可以考虑一个问题，可不可以直接求出最大的${p_i}^{t_i}$，然后计算$N!$中有多少个${p_i}$。提示：N=4，B=40.

\section{寻找发帖“水王”} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:water-king}

% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\subsubsection{问题}
给定一个整型数组，每个数组元素表示一个ID，数组长度为N，数组中有一个ID出现的次数超过了数组长度的一半，求出这个ID。

\subsubsection{解法1}
最简单的解法就是暴力枚举每一个数组元素，判断该元素是否超过一半。时间复杂度是$O(N^2)$。

然后我们考虑对数组进行排序（很多问题一旦排序之后就会有思路了），这时候数组的中位数一定就是我们要求的ID。时间复杂度是$O(Nlg(N))$。

最后，我们考虑这样一个场景，让不同的ID进行PK，最后剩下的一定就是超过一半的ID。可以用一个栈来模拟数组中的元素PK的过程。

\begin{Code}
// 时间复杂度O(N)，空间复杂度O(N)
int findMostWithStack(int[] ids) {
    Stack<Integer> stack = new Stack<Integer>();
    for(int i=0;i<ids.length;i++) {
        if(stack.isEmpty()) {
            stack.push(ids[i]);
		} else {
        if(stack.peek()==ids[i]) stack.push(ids[i]);
        else stack.pop();
    }
}
return stack.peek();
}
\end{Code}

\subsubsection{解法2}
下面我们就来考虑一下是否可以降低空间复杂度。其实上面的做法中我们对于栈中的元素并不关心，我们只关心当前栈顶元素和栈的大小，所以我们就可以不用栈来处理了，用两个变量记录栈的大小和栈顶元素即可。

\begin{Code}
// 时间复杂度O(N)，空间复杂度O(1)
public int findMost(int[] ids) {
    int candidate = -1, count = 0;
    for (int i = 0; i < ids.length; i++) {
        if (count == 0) {
            candidate = ids[i];
            count = 1;
        } else {
            if (ids[i] == candidate) count++;
            else count--;
        }
    }
    return candidate;
}
\end{Code}

\subsubsection{解法3}
利用哈希表。


\subsubsection{扩展问题1}
原问题中保证一定存在一个元素超过一半，那么如果去掉这个条件呢？求出这个元素的下标（数组下标从0开始），如果不存在则返回-1.

\subsubsection{解法}
如果不存在超过一半的元素，上面的两个解法其实并不能正确返回。比如[1,2,3]，返回的就是3.其实这里要做的就是对这个得到的结果进行判断出现次数是否超过一半，时间和空间复杂度都不改变。

代码略。
\subsubsection{扩展问题2}
有3个元素出现的次数超过了数组长度的$\frac{1}{4}$，找出这3个元素。

\subsubsection{解法}
先排序再查找是可以找出的，时间复杂度是$O(Nlg(N))$，这里就不给出具体代码了。